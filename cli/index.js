#!/usr/bin/env node

const fs = require('fs');

function generateShader (args) {
  const ruleString = args[0] || null;
  let outOfBoundValue = args[1] || 'wrap';

  outOfBoundValue = outOfBoundValue == 'wrap' || outOfBoundValue == 'clamp' ? outOfBoundValue : parseInt(outOfBoundValue, 10);

  console.log(generator(ruleString, outOfBoundValue));
}

function extractInformation (content) {
  // not critical, dumb regular expressions will do
  const regexVersion = new RegExp('^/\\*\\*[\\S\\s]+cellular-automata-voxel-shader ([0-9.]+)[\\S\\s]+\\*/', 'mg');
  const regexRuleString = new RegExp('^/\\*\\*[\\S\\s]+Rule : (.+)[\\S\\s]+\\*/', 'mg');
  const regexOutOfBound = new RegExp('^/\\*\\*[\\S\\s]+Out of bound value : (.+)[\\S\\s]+\\*/', 'mg');
  const versionMatch = regexVersion.exec(content);
  const ruleStringMatch = regexRuleString.exec(content);
  const outOfBoundMatch = regexOutOfBound.exec(content);

  return {
    version : versionMatch ? versionMatch[1] : null,
    ruleString : ruleStringMatch ? ruleStringMatch[1] : null,
    outOfBoundValue : outOfBoundMatch ? outOfBoundMatch[1] : null,
    valid : versionMatch && ruleStringMatch && outOfBoundMatch
  };
}

function displayInformation (filename) {
  let content;

  try {
    content = fs.readFileSync(filename).toString();
  } catch (e) {
    content = null;
  }

  const information = extractInformation(content);

  if (information.valid) {
    console.log(filename + ' : ' + information.ruleString + ' : ' + information.outOfBoundValue + ' : generated by cavoxelshader ' + information.version);
  } else {
    console.log(filename + ' : not generated by cavoxelshader');
  }
}

function infoCommand (args) {
  const filename = args[1] || null;

  if (filename) {
    displayInformation(filename);
  } else {
    fs.readdirSync('./').map(function(file) {
      if (file.indexOf('.') !== 0 && fs.lstatSync(file).isFile()) {
        displayInformation(file);
      }
    });
  }
}

const generator = require('./../');
const args = process.argv.slice(2);

if (args[0] === 'info') {
  infoCommand(args);
} else {
  generateShader(args);
}